{"version":3,"file":"nft-ownership-sync.js","sourceRoot":"","sources":["../../src/services/nft-ownership-sync.ts"],"names":[],"mappings":"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","sourcesContent":["import { D1Database } from '@cloudflare/workers-types';\nimport {\n  erc721Abi,\n  getAddress,\n  parseAbiItem,\n  PublicClient,\n} from 'viem';\n\nconst ERC721_TRANSFER_EVENT = parseAbiItem(\n  'event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)'\n);\n\ntype TokenRange = { start: number; end: number };\ntype TokenRangeMap = Record<string, TokenRange>;\n\n/**\n * For a specific NFT collection and a given tokenId range [start, end],\n * calls ownerOf and stores the holder in the DB.\n * - Only updates the holder; metadata fields (type/gender/parts/image) are untouched.\n * - All DB writes are executed via a single batch.\n */\nasync function fetchAndStoreNftOwnershipRange(\n  env: { DB: D1Database },\n  client: PublicClient,\n  nftAddress: string,\n  start: number,\n  end: number\n): Promise<void> {\n  const upsertSql = `\n    INSERT INTO nfts (nft_address, token_id, holder)\n    VALUES (?, ?, ?)\n    ON CONFLICT(nft_address, token_id) DO UPDATE SET\n      holder = excluded.holder\n  `;\n\n  // 1. Fetch all owners in parallel (on-chain calls)\n  const ownerships = await Promise.all(\n    Array.from({ length: end - start + 1 }, (_, idx) => {\n      const tokenId = start + idx;\n      return client\n        .readContract({\n          address: nftAddress as `0x${string}`,\n          abi: erc721Abi,\n          functionName: 'ownerOf',\n          args: [BigInt(tokenId)],\n        })\n        .then((owner) => ({ tokenId, owner }));\n    })\n  );\n\n  // 2. Build all DB statements and execute them in a single batch\n  const statements = ownerships.map(({ tokenId, owner }) =>\n    env.DB.prepare(upsertSql).bind(nftAddress, tokenId, owner)\n  );\n\n  if (statements.length > 0) {\n    await env.DB.batch(statements);\n  }\n}\n\n/**\n * Sync NFT ownership based on Transfer events.\n * - Only applies to tokenIds within the provided tokenRanges.\n * - Only updates the holder field; metadata fields remain unchanged.\n * - Uses batch execution for all DB mutations.\n */\nasync function syncNftOwnershipFromEvents(\n  env: { DB: D1Database },\n  client: PublicClient,\n  tokenRanges: TokenRangeMap,\n  blockStep: number\n): Promise<void> {\n  const statusRow = await env.DB.prepare(\n    `SELECT last_synced_block_number FROM contract_event_sync_status WHERE contract_type = ?`\n  )\n    .bind('ERC721')\n    .first<{ last_synced_block_number: number }>();\n\n  const lastSyncedBlockNumber = statusRow\n    ? BigInt(statusRow.last_synced_block_number)\n    : undefined;\n\n  if (lastSyncedBlockNumber === undefined) {\n    throw new Error('No previously synced block found for ERC721');\n  }\n\n  let toBlock = lastSyncedBlockNumber + BigInt(blockStep);\n  const currentBlock = await client.getBlockNumber();\n\n  if (toBlock > currentBlock) {\n    toBlock = currentBlock;\n  }\n\n  let fromBlock = toBlock - BigInt(blockStep) * 2n;\n  if (fromBlock < 0n) {\n    fromBlock = 0n;\n  }\n\n  const logs = await client.getLogs({\n    address: Object.keys(tokenRanges) as `0x${string}`[],\n    event: ERC721_TRANSFER_EVENT,\n    fromBlock,\n    toBlock,\n  });\n\n  const upsertHolderSql = `\n    INSERT INTO nfts (nft_address, token_id, holder)\n    VALUES (?, ?, ?)\n    ON CONFLICT(nft_address, token_id) DO UPDATE SET\n      holder = excluded.holder\n  `;\n\n  const statements: any[] = [];\n\n  // 1. Build holder update statements for relevant tokens\n  for (const log of logs) {\n    const nftAddress = getAddress(log.address);\n    const tokenId = Number(log.args.tokenId);\n    const to = log.args.to as string;\n\n    const range = tokenRanges[nftAddress];\n    if (range && tokenId >= range.start && tokenId <= range.end) {\n      statements.push(\n        env.DB.prepare(upsertHolderSql).bind(nftAddress, tokenId, to)\n      );\n    }\n  }\n\n  // 2. Update sync checkpoint\n  statements.push(\n    env.DB.prepare(\n      `UPDATE contract_event_sync_status\n       SET last_synced_block_number = ?, last_synced_at = strftime('%s','now')\n       WHERE contract_type = ?`\n    ).bind(Number(toBlock), 'ERC721')\n  );\n\n  // 3. Execute all DB mutations in a single batch\n  if (statements.length > 0) {\n    await env.DB.batch(statements);\n  }\n}\n\nexport { fetchAndStoreNftOwnershipRange, syncNftOwnershipFromEvents };\n"]}