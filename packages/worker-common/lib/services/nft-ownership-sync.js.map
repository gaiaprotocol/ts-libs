{"version":3,"file":"nft-ownership-sync.js","sourceRoot":"","sources":["../../src/services/nft-ownership-sync.ts"],"names":[],"mappings":"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","sourcesContent":["import { D1Database } from '@cloudflare/workers-types';\nimport {\n  erc721Abi,\n  getAddress,\n  parseAbiItem,\n  PublicClient,\n} from 'viem';\n\nconst ERC721_TRANSFER_EVENT = parseAbiItem(\n  'event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)'\n);\n\ntype TokenRange = { start: number; end: number };\ntype TokenRangeMap = Record<string, TokenRange>;\n\n/**\n * 특정 NFT 컬렉션의 지정된 tokenId 범위(start~end)에 대해 ownerOf 호출 후 DB에 저장\n * - 메타데이터(type/gender/parts/image)는 건드리지 않고 holder만 갱신\n */\nasync function fetchAndStoreNftOwnershipRange(\n  env: { DB: D1Database },\n  client: PublicClient,\n  nftAddress: string,\n  start: number,\n  end: number\n): Promise<void> {\n  const upsertSql = `\n    INSERT INTO nfts (nft_address, token_id, holder)\n    VALUES (?, ?, ?)\n    ON CONFLICT(nft_address, token_id) DO UPDATE SET\n      holder = excluded.holder\n  `;\n\n  const tasks: Promise<void>[] = [];\n  for (let tokenId = start; tokenId <= end; tokenId++) {\n    tasks.push((async () => {\n      const owner = await client.readContract({\n        address: nftAddress as `0x${string}`,\n        abi: erc721Abi,\n        functionName: 'ownerOf',\n        args: [BigInt(tokenId)],\n      });\n\n      await env.DB.prepare(upsertSql)\n        .bind(nftAddress, tokenId, owner)\n        .run();\n    })());\n  }\n\n  await Promise.all(tasks);\n}\n\n/**\n * Transfer 이벤트 기반으로 소유자 업데이트\n * - 지정된 tokenRanges에 해당하는 토큰만 반영\n * - 메타데이터 필드는 유지하고 holder만 갱신\n * - 블록 범위 계산을 last+1 ~ last+step 로 단순화\n */\nasync function syncNftOwnershipFromEvents(\n  env: { DB: D1Database },\n  client: PublicClient,\n  tokenRanges: TokenRangeMap,\n  blockStep: number\n): Promise<void> {\n  const statusRow = await env.DB.prepare(\n    `SELECT last_synced_block_number FROM contract_event_sync_status WHERE contract_type = ?`\n  )\n    .bind('ERC721')\n    .first<{ last_synced_block_number: number }>();\n\n  const lastSyncedBlockNumber = statusRow\n    ? BigInt(statusRow.last_synced_block_number)\n    : undefined;\n\n  if (lastSyncedBlockNumber === undefined) {\n    throw new Error('No previously synced block found for ERC721');\n  }\n\n  let toBlock = lastSyncedBlockNumber + BigInt(blockStep);\n  const currentBlock = await client.getBlockNumber();\n\n  if (toBlock > currentBlock) {\n    toBlock = currentBlock;\n  }\n\n  let fromBlock = toBlock - BigInt(blockStep) * 2n;\n  if (fromBlock < 0n) {\n    fromBlock = 0n;\n  }\n\n  const logs = await client.getLogs({\n    address: Object.keys(tokenRanges) as `0x${string}`[],\n    event: ERC721_TRANSFER_EVENT,\n    fromBlock,\n    toBlock,\n  });\n\n  // holder만 갱신하는 UPSERT\n  const upsertHolderSql = `\n    INSERT INTO nfts (nft_address, token_id, holder)\n    VALUES (?, ?, ?)\n    ON CONFLICT(nft_address, token_id) DO UPDATE SET\n      holder = excluded.holder\n  `;\n\n  for (const log of logs) {\n    const nftAddress = getAddress(log.address);\n    const tokenId = Number(log.args.tokenId);\n    const to = log.args.to as string;\n\n    // 지정된 토큰 범위에 속하는 경우에만 반영\n    const range = tokenRanges[nftAddress];\n    if (range && tokenId >= range.start && tokenId <= range.end) {\n      await env.DB.prepare(upsertHolderSql)\n        .bind(nftAddress, tokenId, to)\n        .run();\n    }\n  }\n\n  await env.DB.prepare(\n    `UPDATE contract_event_sync_status\n     SET last_synced_block_number = ?, last_synced_at = strftime('%s','now')\n     WHERE contract_type = ?`\n  )\n    .bind(Number(toBlock), 'ERC721')\n    .run();\n}\n\nexport { fetchAndStoreNftOwnershipRange, syncNftOwnershipFromEvents };\n"]}