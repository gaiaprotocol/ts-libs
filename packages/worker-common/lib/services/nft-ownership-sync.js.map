{"version":3,"file":"nft-ownership-sync.js","sourceRoot":"","sources":["../../src/services/nft-ownership-sync.ts"],"names":[],"mappings":"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","sourcesContent":["import { D1Database } from '@cloudflare/workers-types';\nimport {\n  erc721Abi,\n  getAddress,\n  parseAbiItem,\n  PublicClient,\n} from 'viem';\n\nconst ERC721_TRANSFER_EVENT = parseAbiItem(\n  'event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)'\n);\n\ntype TokenRange = { start: number; end: number };\ntype TokenRangeMap = Record<string, TokenRange>;\n\n/**\n * 특정 NFT 컬렉션의 지정된 tokenId 범위(start~end)에 대해 ownerOf 호출 후 DB에 저장\n */\nasync function fetchAndStoreNftOwnershipRange(\n  env: { DB: D1Database },\n  client: PublicClient,\n  nftAddress: string,\n  start: number,\n  end: number\n): Promise<void> {\n  const promises: Promise<void>[] = [];\n\n  for (let tokenId = start; tokenId <= end; tokenId++) {\n    const promise = ((async () => {\n      const owner = await client.readContract({\n        address: nftAddress as `0x${string}`,\n        abi: erc721Abi,\n        functionName: 'ownerOf',\n        args: [BigInt(tokenId)],\n      });\n\n      await env.DB.prepare(\n        `INSERT OR REPLACE INTO nfts (nft_address, token_id, holder) VALUES (?, ?, ?)`\n      ).bind(nftAddress, tokenId, owner).run();\n    })());\n\n    promises.push(promise);\n  }\n\n  await Promise.all(promises);\n}\n\n/**\n * Transfer 이벤트 기반으로 소유자 업데이트\n */\nasync function syncNftOwnershipFromEvents(\n  env: { DB: D1Database },\n  client: PublicClient,\n  tokenRanges: TokenRangeMap,\n  blockStep: number\n): Promise<void> {\n  const statusRow = await env.DB.prepare(\n    `SELECT last_synced_block_number FROM contract_event_sync_status WHERE contract_type = ?`\n  )\n    .bind('ERC721')\n    .first<{ last_synced_block_number: number }>();\n\n  const lastSyncedBlockNumber = statusRow\n    ? BigInt(statusRow.last_synced_block_number)\n    : undefined;\n\n  if (lastSyncedBlockNumber === undefined) {\n    throw new Error('No previously synced block found for ERC721');\n  }\n\n  let toBlock = lastSyncedBlockNumber + BigInt(blockStep);\n  const currentBlock = await client.getBlockNumber();\n\n  if (toBlock > currentBlock) {\n    toBlock = currentBlock;\n  }\n\n  let fromBlock = toBlock - BigInt(blockStep) * 2n;\n  if (fromBlock < 0n) {\n    fromBlock = 0n;\n  }\n\n  const logs = await client.getLogs({\n    address: Object.keys(tokenRanges) as `0x${string}`[],\n    event: ERC721_TRANSFER_EVENT,\n    fromBlock,\n    toBlock,\n  });\n\n  const transferEvents = logs.map((log) => ({\n    nftAddress: getAddress(log.address),\n    from: log.args.from,\n    to: log.args.to,\n    tokenId: Number(log.args.tokenId),\n    blockNumber: log.blockNumber,\n    transactionHash: log.transactionHash,\n    logIndex: log.logIndex,\n  }));\n\n  for (const { nftAddress, tokenId, to } of transferEvents) {\n    await env.DB.prepare(\n      `INSERT OR REPLACE INTO nfts (nft_address, token_id, holder) VALUES (?, ?, ?)`\n    ).bind(nftAddress, tokenId, to).run();\n  }\n\n  await env.DB.prepare(\n    `UPDATE contract_event_sync_status\n     SET last_synced_block_number = ?, last_synced_at = strftime('%s','now')\n     WHERE contract_type = ?`\n  ).bind(Number(toBlock), 'ERC721').run();\n}\n\nexport { fetchAndStoreNftOwnershipRange, syncNftOwnershipFromEvents };\n"]}